#' Prioritize Genes by Permutation-Based DE-Neighborhood Enrichment
#'
#' Test whether each gene of interest has more differentially expressed (DE) neighbors than
#' expected by chance in a background interaction network, using an empirical null
#' distribution generated by permutation. For each gene, the observed number of DE
#' neighbors (1-hop) is compared to counts obtained from randomly relabeling DE genes.
#'
#' @param genes_oi Character vector of genes of interest to prioritize.
#'
#' @param de_genes Character vector of DE genes. Identifiers must match network vertex names.
#'
#' @param net Optional interaction edge-list `data.frame`. If `NULL`, loads the dataset `net`
#'   bundled with \pkg{CrosstalkX} via `data("net", package = "CrosstalkX")`. The first two
#'   columns are treated as endpoints and renamed to `source` and `target`.
#'
#' @param B Integer. Number of permutations used to construct the empirical null distribution.
#'   Default is `100`.
#'
#' @param p_adj_method Character string specifying the multiple-testing adjustment method
#'   passed to [stats::p.adjust()]. Default is `"BH"`.
#'
#' @param alpha Numeric in (0, 1). Significance cutoff applied to adjusted p-values (FDR).
#'   Default is `0.05`.
#'
#' @param export Logical. If `TRUE` (default), writes CSV files for all genes and significant
#'   genes only (see Details).
#'
#' @details
#' The procedure:
#' \enumerate{
#'   \item Load the network (if `net` is `NULL`), keep edges whose endpoints are in
#'   `unique(c(genes_oi, de_genes))`, remove missing/empty endpoints, and build an undirected
#'   graph with [igraph::graph_from_data_frame()].
#'   \item Restrict `genes_oi` and `de_genes` to vertices present in the graph.
#'   \item For each gene in `genes_oi`, compute the observed number of DE neighbors using the
#'   1-hop neighborhood from [igraph::ego()] (self excluded).
#'   \item Repeat `B` times: sample `length(de_genes)` random vertices without replacement,
#'   treat them as the DE set, and recompute DE-neighbor counts for all genes of interest.
#'   \item Compute a one-sided empirical p-value per gene:
#'   \deqn{p = \frac{1 + \sum_{b=1}^{B} I(X_b \ge X_{obs})}{B+1}}
#'   where \eqn{X_{obs}} is the observed DE-neighbor count and \eqn{X_b} is the permuted count.
#'   \item Adjust p-values using `p_adj_method` and compute an empirical z-score:
#'   \deqn{z = \frac{X_{obs} - \mu_{null}}{\sigma_{null} + 10^{-9}}}
#'   \item If `export = TRUE`, write:
#'   \itemize{
#'     \item `prioritized_genes_perm_all.csv` (all tested genes)
#'     \item `prioritized_genes_perm_FDR_<alpha>.csv` (significant genes only)
#'   }
#' }
#'
#' @return A `data.frame` of significant genes with columns:
#' \describe{
#'   \item{gene}{Gene identifier.}
#'   \item{obs_de_neighbors}{Observed number of DE neighbors.}
#'   \item{null_mean}{Mean DE-neighbor count under permutation.}
#'   \item{null_sd}{Standard deviation of permuted counts.}
#'   \item{z_empirical}{Empirical z-score based on permutation mean/sd.}
#'   \item{pval}{One-sided empirical p-value.}
#'   \item{padj}{Adjusted p-value (FDR) using `p_adj_method`.}
#' }
#' If no genes pass the threshold, an empty `data.frame` with the same columns is returned.
#'
#' @note
#' This implements a random-labeling null in which DE labels are exchangeable across vertices
#' in the induced subgraph. If DE status is strongly associated with degree or other network
#' properties, consider degree-matched or stratified permutation schemes.
#'
#' @seealso [igraph::graph_from_data_frame()], [igraph::ego()], [stats::p.adjust()]
#'
#' @importFrom igraph graph_from_data_frame V ego
#' @importFrom pbapply pblapply
#' @importFrom data.table fwrite
#' @importFrom rlang .data
#' @export
#'
#' @examples
#' \dontrun{
#' sig <- prioritize_de(
#'   genes_oi = rownames(expr),
#'   de_genes = de_genes,
#'   net = net,
#'   B = 100,
#'   alpha = 0.05
#' )
#' head(sig, 20)
#' }



prioritize_de <- function( genes_oi, de_genes, net = NULL,
                    B = 100,                 # permutations
                    p_adj_method = "BH",
                    alpha = 0.05,             # FDR threshold
                    export = TRUE  ) {

              if (!requireNamespace("igraph", quietly = TRUE)) stop("Install 'igraph'.")
              if (!requireNamespace("pbapply", quietly = TRUE)) stop("Install 'pbapply'.")
              if (!requireNamespace("data.table", quietly = TRUE)) stop("Install 'data.table'.")

              # Load base PPI if not provided
              if (is.null(net)) {
                data("net", package = "CrosstalkX", envir = environment())
                net <- get("net", envir = environment())
              }

              colnames(net)[1:2] <- c("source", "target")
              all_genes <- unique(c(de_genes, genes_oi))
              net <- net[net$source %in% all_genes & net$target %in% all_genes, ]
              net <- net[complete.cases(net) & net$source != "" & net$target != "", ]

              g <- igraph::graph_from_data_frame(net, directed = FALSE)
              vnames <- igraph::V(g)$name
              genes_oi <- intersect(genes_oi, vnames)
              de_genes <- intersect(de_genes, vnames)

              if (length(de_genes) == 0) stop("No DE genes found in the network after filtering.")
              if (length(genes_oi) == 0) stop("No genes_oi found in the network after filtering.")

              # vertex ids for genes_oi
              vid <- match(genes_oi, vnames)

              # Precompute neighbor vertex ids
              nei_ids <- lapply(
                igraph::ego(g, order = 1, nodes = vid, mode = "all", mindist = 1),
                function(vs) as.integer(vs)
              )

              # Observed DE-neighbor counts
              de_flag <- logical(length(vnames))
              de_flag[match(de_genes, vnames)] <- TRUE

              obs <- vapply(nei_ids, function(ids) sum(de_flag[ids]), integer(1))
              names(obs) <- genes_oi

              n_de <- length(de_genes)

              # One permutation: random DE set -> counts of DE neighbors for all genes_oi
              one_perm <- function(i) {
                rnd_idx <- sample.int(length(vnames), n_de, replace = FALSE)
                rnd_flag <- logical(length(vnames))
                rnd_flag[rnd_idx] <- TRUE
                vapply(nei_ids, function(ids) sum(rnd_flag[ids]), integer(1))
              }

              # Run permutations with progress bar
              null_list <- pbapply::pblapply(seq_len(B), one_perm)

              null_mat <- do.call(cbind, null_list)  # length(genes_oi) x B

              # Empirical one-sided p-value: P(null >= obs)
              pval <- (rowSums(null_mat >= obs) + 1) / (B + 1)
              padj <- stats::p.adjust(pval, method = p_adj_method)

              # Effect size (helpful alongside p-values)
              exp_null <- rowMeans(null_mat)
              sd_null  <- apply(null_mat, 1, stats::sd)
              z_emp <- (obs - exp_null) / (sd_null + 1e-9)

              res <- data.frame(
                        gene = genes_oi,
                        obs_de_neighbors = obs,
                        null_mean = exp_null,
                        null_sd = sd_null,
                        z_empirical = z_emp,
                        pval = pval,
                        padj = padj,
                        stringsAsFactors = FALSE
                      )

              # prioritize: smallest pval, then largest empirical z, then largest obs
              res <- res[order(-res$obs_de_neighbors, res$pval, -res$z_empirical, -res$obs_de_neighbors), ]
              sig <- res[res$pval <= alpha, , drop = FALSE]

              if (export) {
                data.table::fwrite(res, "prioritized_genes_perm_all.csv")
                data.table::fwrite(sig, paste0("prioritized_genes_perm_FDR_", alpha, ".csv"))
                }

              return(list(res=res, sig=sig))
             }

