#' Cross-talk Analysis Between Terms Using Mutual Information and Permutation Testing
#'
#' Perform permutation-based inference of significant term–term cross-talk using mutual
#' information (MI) and interaction degree derived from a gene–gene interaction network.
#' Terms are represented as gene sets; observed term–term connectivity is compared to a
#' null distribution generated by randomizing the gene→term membership structure while
#' approximately preserving degree constraints.
#'
#' @param gset_list A **named** list of character vectors, where each element is a term
#'   gene set. Gene identifiers must match the vertex names used in `mi_df` (edge endpoints).
#'
#' @param mi_df A `data.frame` describing a gene–gene interaction network. Must contain at
#'   least two columns defining edge endpoints (gene identifiers) and an edge attribute
#'   column named `mi_score` used as MI weights. The table is converted internally to an
#'   undirected \pkg{igraph} graph.
#'
#' @param iter Integer. Number of permutations used to generate the null distribution.
#'   Default is `100`.
#'
#' @param prefix Character. Prefix used when writing results to disk. The output file is
#'   written as `paste0(prefix, "_CrosstalkX.csv")`. Default is `"res"`.
#'
#' @details
#' The procedure:
#' \enumerate{
#'   \item Constructs an undirected gene–gene graph from `mi_df`.
#'   \item Filters each gene set in `gset_list` to genes present in the gene graph; empty
#'   terms are dropped.
#'   \item Builds a directed membership graph with edges gene \eqn{\rightarrow} term using
#'   \code{stack(gset_list)} and [igraph::graph_from_data_frame()].
#'   \item Computes observed term–term interaction statistics with
#'   [compute_interactions()] and overlap (Jaccard) with [compute_jaccard()], then joins
#'   the results by (`Term1`, `Term2`).
#'   \item Generates a null distribution by sampling directed graphs with fixed in/out
#'   degree sequences via [igraph::sample_degseq()]. For each
#'   successful permutation, term–term interaction statistics are recomputed.
#'   \item Computes one-sided empirical permutation p-values using:
#'   \deqn{p = \frac{\#\{T_b \ge T_{obs}\} + 1}{B + 1}}
#'   where \eqn{T} is the statistic of interest and \eqn{B} is the number of successful
#'   permutations.
#'   \item Adds term gene-hit strings (`Term1_hits`, `Term2_hits`) for interpretability and
#'   writes results to disk with [data.table::fwrite()].
#' }
#'
#' Permutations that fail (e.g., due to errors during interaction computation) are skipped.
#'
#' @return A `data.frame` of pairwise term interactions containing (at minimum):
#' \describe{
#'   \item{Term1}{First term identifier.}
#'   \item{Term2}{Second term identifier.}
#'   \item{degree}{Number of gene–gene edges connecting the two terms.}
#'   \item{deg_norm}{`degree` normalized by \eqn{|t_1| + |t_2|}.}
#'   \item{mi_score}{Sum of MI (`mi_score`) across connecting edges.}
#'   \item{mi_norm}{`mi_score` normalized by \eqn{|t_1| + |t_2|}.}
#'   \item{Jaccard}{Jaccard similarity between term gene sets.}
#'   \item{pval_deg_norm}{Permutation p-value for `deg_norm` (one-sided, \eqn{\ge}).}
#'   \item{pval_mi_norm}{Permutation p-value for `mi_norm` (one-sided, \eqn{\ge}).}
#'   \item{Term1_hits}{Comma-separated genes in `Term1` after filtering to the gene graph.}
#'   \item{Term2_hits}{Comma-separated genes in `Term2` after filtering to the gene graph.}
#' }
#'
#' @seealso [compute_interactions()], [compute_jaccard()]
#'
#' @importFrom igraph graph_from_data_frame sample_degseq degree V
#' @importFrom dplyr left_join bind_rows group_by summarise mutate select
#' @importFrom data.table fwrite
#' @importFrom rlang .data
#' @export
#'
#' @examples
#' \dontrun{
#' gset_list <- list(
#'   TermA = c("TP53", "EGFR", "MYC"),
#'   TermB = c("EGFR", "KRAS")
#' )
#'
#' mi_df <- data.frame(
#'   from = c("TP53", "EGFR", "MYC"),
#'   to   = c("EGFR", "KRAS", "KRAS"),
#'   mi_score = c(0.6, 0.1, 0.004)
#' )
#'
#' res <- compute_crosstalk(gset_list, mi_df, iter = 100, prefix = "demo")
#' head(res)
#' }


compute_crosstalk <- function(gset_list, mi_df, iter = 100, prefix = "res") {

          if (!requireNamespace("igraph", quietly = TRUE)) stop("Install 'igraph'.")
          if (!requireNamespace("pbapply", quietly = TRUE)) stop("Install 'pbapply'.")
          if (!requireNamespace("dplyr", quietly = TRUE)) stop("Install 'dplyr'.")
          if (!requireNamespace("data.table", quietly = TRUE)) stop("Install 'data.table'.")
          if (!requireNamespace("rlang", quietly = TRUE)) stop("Install 'rlang'.")

          # empirical one-sided permutation p-value
          permute_test <- function(observed_count, random_counts) {
            obs <- as.numeric(observed_count)[1]
            rnd <- as.numeric(random_counts)
            if (length(rnd) == 0 || all(is.na(rnd))) return(NA_real_)
            rnd <- rnd[!is.na(rnd)]
            (sum(rnd >= obs) + 1) / (length(rnd) + 1)
          }

          # Gene–gene graph
          g_graph <- igraph::graph_from_data_frame(mi_df, directed = FALSE)

          # Filter gene sets to genes present in gene graph
          gset_list <- lapply(gset_list, function(l) l[l %in% igraph::V(g_graph)$name])
          gset_list <- gset_list[lengths(gset_list) > 0]
          if (length(gset_list) == 0) stop("No gene sets left after filtering to mi graph genes.")
          if (is.null(names(gset_list)) || any(names(gset_list) == "")) {
            stop("gset_list must be a *named* list (names = pathway IDs).")
          }

          genes <- unique(unlist(gset_list))
          terms <- unique(names(gset_list))

          # Pathway membership graph (directed gene -> pathway)
          p_edges <- utils::stack(gset_list)
          p_graph <- igraph::graph_from_data_frame(p_edges, directed = TRUE)

          # Observed interactions + Jaccard
          observed <- compute_interactions(p_graph, g_graph, terms, genes)
          jaccard  <- compute_jaccard(p_graph, terms, genes)

          # Join observed + jaccard
          res <- observed |>
                dplyr::left_join(jaccard, by = c("Term1", "Term2"))

          # Permutations using directed configuration model (fixed in/out degrees)
          v_all <- c(genes, terms)  # vertex order: genes first, then terms
          nG <- length(genes)
          nP <- length(terms)

          out.deg <- c(igraph::degree(p_graph, v = genes, mode = "out"), rep(0, nP))
          in.deg  <- c(rep(0, nG), igraph::degree(p_graph, v = terms, mode = "in"))

          random <- pbapply::pblapply(seq_len(iter), function(b) {
            rewired <- igraph::sample_degseq(
                        out.deg = out.deg,
                        in.deg  = in.deg,
                        method  = "configuration"
                      )
            igraph::V(rewired)$name <- v_all

            tryCatch(
              compute_interactions(rewired, g_graph, terms, genes),
              error = function(e) NULL
            )
          })

          random <- Filter(Negate(is.null), random)

          # Attach p-values
          if (length(random) == 0) {
            res$pval_deg_norm <- NA_real_
            res$pval_mi_norm  <- NA_real_
          } else {

            rand_df <- dplyr::bind_rows(random)

            # keys
            res$key     <- paste(res$Term1, res$Term2, sep = "||")
            rand_df$key <- paste(rand_df$Term1, rand_df$Term2, sep = "||")

            # summarize null distributions per key (list-columns)
            rand_sum <- rand_df |>
              dplyr::group_by(.data$key) |>
              dplyr::summarise(
                null_deg_norm = list(.data$deg_norm),
                null_mi_norm  = list(.data$mi_norm),
                .groups = "drop"
              )

            # join once, then compute p-values
            res <- res |>
              dplyr::left_join(rand_sum, by = "key") |>
              dplyr::mutate(
                pval_deg_norm = mapply(permute_test, .data$deg_norm, .data$null_deg_norm),
                pval_mi_norm  = mapply(permute_test, .data$mi_norm,  .data$null_mi_norm)
              ) |>
              dplyr::select(-.data$key, -.data$null_deg_norm, -.data$null_mi_norm)
          }

          # Add gene hits for interpretability
          paths_hits <- lapply(gset_list, function(x) paste(x, collapse = ","))
          res$Term1_hits <- paths_hits[res$Term1]
          res$Term2_hits <- paths_hits[res$Term2]

          res <- res[order(-res$degree, res$pval_deg_norm), ]

          # export
          data.table::fwrite(res, paste0(prefix, "_CrosstalkX.csv"))

          res
}
